<?php

namespace AlterPHP\EasyAdminMongoOdmBundle\DependencyInjection;

use AlterPHP\EasyAdminMongoOdmBundle\Cache\ConfigWarmer;
use Symfony\Component\Config\FileLocator;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader;
use Symfony\Component\HttpKernel\DependencyInjection\Extension;

/**
 * This is the class that loads and manages your bundle configuration.
 *
 * @see http://symfony.com/doc/current/cookbook/bundles/extension.html
 */
class EasyAdminMongoOdmExtension extends Extension
{
    /**
     * {@inheritdoc}
     */
    public function load(array $configs, ContainerBuilder $container)
    {
        $configs = $this->processConfigFiles($configs);

        // EasyAdminMongoOdm configuration
        $configuration = new Configuration();
        $config = $this->processConfiguration($configuration, $configs);

        // EasyAdmin Mongo ODM configuration
        $container->setParameter('easyadmin_mongo_odm.config', $config);
        $container->setParameter('easyadmin_mongo_odm.cache.dir', $container->getParameter('kernel.cache_dir').'/easy_admin_mongo_odm');

        $loader = new Loader\XmlFileLoader($container, new FileLocator(__DIR__.'/../Resources/config'));
        $loader->load('services.xml');

        if ($container->getParameter('kernel.debug')) {
            // // in 'dev', use the built-in Symfony exception listener
            // $container->removeDefinition('easyadmin.listener.exception');
            // avoid parsing the entire config in 'dev' (even for requests unrelated to the backend)
            $container->removeDefinition(ConfigWarmer::class);
        }
    }

    /**
     * This method allows to define the document configuration is several files.
     * Without this, Symfony doesn't merge correctly the 'documents' config key
     * defined in different files.
     *
     * @param array $configs
     *
     * @return array
     */
    private function processConfigFiles(array $configs)
    {
        $existingDocumentNames = array();

        foreach ($configs as $i => $config) {
            if (array_key_exists('documents', $config)) {
                $processedConfig = array();

                foreach ($config['documents'] as $key => $value) {
                    $documentConfig = $this->normalizeDocumentConfig($key, $value);
                    $documentName = $this->getUniqueDocumentName($key, $documentConfig, $existingDocumentNames);
                    $documentConfig['name'] = $documentName;

                    $processedConfig[$documentName] = $documentConfig;

                    $existingDocumentNames[] = $documentName;
                }

                $config['documents'] = $processedConfig;
            }

            $configs[$i] = $config;
        }

        return $configs;
    }

    /**
     * Transforms the two simple configuration formats into the full expanded
     * configuration. This allows to reuse the same method to process any of the
     * different configuration formats.
     *
     * These are the two simple formats allowed:
     *
     * # Config format #1: no custom document name
     * easy_admin:
     *     documents:
     *         - AppBundle\Document\User
     *
     * # Config format #2: simple config with custom document name
     * easy_admin:
     *     documents:
     *         User: AppBundle\Document\User
     *
     * And this is the full expanded configuration syntax generated by this method:
     *
     * # Config format #3: expanded document configuration with 'class' parameter
     * easy_admin:
     *     documents:
     *         User:
     *             class: AppBundle\Document\User
     *
     * @param mixed $documentName
     * @param mixed $documentConfig
     *
     * @return array
     */
    private function normalizeDocumentConfig($documentName, $documentConfig)
    {
        // normalize config formats #1 and #2 to use the 'class' option as config format #3
        if (!is_array($documentConfig)) {
            $documentConfig = array('class' => $documentConfig);
        }

        // if config format #3 is used, ensure that it defines the 'class' option
        if (!isset($documentConfig['class'])) {
            throw new \RuntimeException(sprintf('The "%s" document must define its associated Doctrine document class using the "class" option.', $documentName));
        }

        return $documentConfig;
    }

    /**
     * The name of the document is included in the URLs of the backend to define
     * the document used to perform the operations. Obviously, the document name
     * must be unique to identify documents unequivocally.
     *
     * This method ensures that the given document name is unique among all the
     * previously existing documents passed as the second argument. This is
     * achieved by iteratively appending a suffix until the document name is
     * guaranteed to be unique.
     *
     * @param string $documentName
     * @param array  $documentConfig
     * @param array  $existingDocumentNames
     *
     * @return string The document name transformed to be unique
     */
    private function getUniqueDocumentName($documentName, array $documentConfig, array $existingDocumentNames)
    {
        // the shortcut config syntax doesn't require to give documents a name
        if (is_numeric($documentName)) {
            $documentClassParts = explode('\\', $documentConfig['class']);
            $documentName = end($documentClassParts);
        }

        $i = 2;
        $uniqueName = $documentName;
        while (in_array($uniqueName, $existingDocumentNames)) {
            $uniqueName = $documentName.($i++);
        }

        $documentName = $uniqueName;

        // make sure that the document name is valid as a PHP method name
        // (this is required to allow extending the backend with a custom controller)
        if (!$this->isValidMethodName($documentName)) {
            throw new \InvalidArgumentException(sprintf('The name of the "%s" document contains invalid characters (allowed: letters, numbers, underscores; the first character cannot be a number).', $documentName));
        }

        return $documentName;
    }

    /**
     * Checks whether the given string is valid as a PHP method name.
     *
     * @param string $name
     *
     * @return bool
     */
    private function isValidMethodName($name)
    {
        return 0 !== preg_match('/^-?[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/', $name);
    }
}
